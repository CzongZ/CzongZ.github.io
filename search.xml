<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Vue随笔</title>
      <link href="/2019/12/09/vue-sui-bi/"/>
      <url>/2019/12/09/vue-sui-bi/</url>
      
        <content type="html"><![CDATA[<h3 id="v-on-的修饰符"><a href="#v-on-的修饰符" class="headerlink" title="v-on 的修饰符"></a>v-on 的修饰符</h3><ul><li>.stop  阻止冒泡时间的发生 比如一个按钮在盒子里，点击按钮盒子的点击事件也会触发</li><li>.prevent 阻止点击事件的默认属性，比如自动提交</li></ul><h4 id="数组可以响应式的方法"><a href="#数组可以响应式的方法" class="headerlink" title="数组可以响应式的方法"></a>数组可以响应式的方法</h4><blockquote><p>如果是通过索引值去修改数组中的元素，界面是做不到响应式的，但是下面的方法可以</p><p>PS：以下都是个人总结和撰写，如有错误，还请指出</p></blockquote><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>push()</td><td>在数组的最后面添加元素，可以添加多个，例如：<code>this.item.push(&quot;aaa&quot;,&quot;bbb&quot;)</code></td></tr><tr><td>pop()</td><td>删除数组的最后一个元素,例如：<code>this.item.pop()</code></td></tr><tr><td>shift()</td><td>删除数组的第一个元素</td></tr><tr><td>unshift()</td><td>在数组的最前面添加元素，可以添加多个</td></tr><tr><td>sort()</td><td>对数组进行ASCLL值排序，从低到高</td></tr></tbody></table><p><strong>还有一个比较特殊的方法splice()</strong></p><p>它可以对数组进行删除元素，添加元素，替换元素的操作</p><p>它可以通过传入的参数不同从而分别实现不同的功能</p><ul><li><p>删除元素：<code>splice(a,b)</code> 第一个参数a：下标开始的位置，第二个参数b：要删除元素的个数</p></li><li><p>替换元素：<code>splice(a,b,c)</code> 第一个参数a：下标开始的位置，第二个参数b：要替换元素的个数，第三个参数c：跟b值相同个数的字符串，例如：<code>splice(1,3,&quot;aaa&quot;,&quot;bbb&quot;,&quot;ccc&quot;)</code></p></li></ul><p><strong>PS</strong>：如果c参数写的字符串大于b的值，它会默认把多出来的值进行添加到数组末尾。</p><ul><li>添加元素：<code>splice(a,0,c)</code>第一个参数a：下标开始的位置，第二个参数b：定值为0的时候就是不删除和替换任何元素，第三个参数c：你想添加的元素，可以多个</li></ul><h4 id="数组的一些高级函数"><a href="#数组的一些高级函数" class="headerlink" title="数组的一些高级函数"></a>数组的一些高级函数</h4><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>filter()</td><td>对数组进行条件筛选，将筛选出来的元素组成一个内部数组并返回</td></tr><tr><td>map()</td><td>对数组的元素进行数值化的操作，将元素组成一个内部数组并返回</td></tr><tr><td>reduce()</td><td>对数组的元素进行汇合，并将得到的值返回</td></tr></tbody></table><blockquote><p>下面对其三个函数进行逐个分析</p></blockquote><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// 初始化一个数组</span><span class="token keyword">const</span> nums <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">111</span><span class="token punctuation">,</span> <span class="token number">222</span><span class="token punctuation">,</span> <span class="token number">333</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">,</span> <span class="token number">40</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true">// 提出一个要求：将这个数组中小于100的元素乘上2，并计算出总和</span><span class="token comment" spellcheck="true">// filter/map/reduce都是需要传入一个回调函数，而reduce稍微特殊，下面会讲</span><span class="token keyword">let</span> total <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// filter中的回调函数有一个要求：必须返回一个boolean值</span>  <span class="token comment" spellcheck="true">// true: 当返回的是true时，函数内部会自动将这次回调获得的元素添加到数组中</span>  <span class="token comment" spellcheck="true">// false: 当返回的是false时，函数内部会自动将这次回调获得的元素过滤掉    </span>  <span class="token comment" spellcheck="true">// 当使用filter函数时，该函数就自动遍历了调用这个函数的数组，并将数组的每个元素代入参数的函数中</span>  <span class="token comment" spellcheck="true">// 所以这个函数在该代码块运行时，会将10,20,111,222,333,30,40一一代入里面，去判断是否小于100</span>  <span class="token keyword">return</span> n <span class="token operator">&lt;</span> <span class="token number">100</span>  <span class="token comment" spellcheck="true">//10,20,30,40都是小于100的所以此时这个函数返回的数组是[10, 20, 30, 40]</span>  <span class="token comment" spellcheck="true">//方便起见，我直接使用链式函数</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//map函数同样会先遍历调用该函数的数组</span>  <span class="token comment" spellcheck="true">//map返回的值是进行数值化操作后的值</span>  <span class="token keyword">return</span> n <span class="token operator">*</span> <span class="token number">2</span>  <span class="token comment" spellcheck="true">//所以这个函数在该代码块运行时会将数组里的元素一一乘上2，并返回到一个数组里</span>  <span class="token comment" spellcheck="true">//此时这个函数返回的数组是[20, 40, 60, 80]</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>preValue<span class="token punctuation">,</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//这个函数需要传入两个参数，第一个带有连个参数的回调函数，第二个是初始化值</span>  <span class="token comment" spellcheck="true">//这个初始化值会被代入到preValue，也就是回调函数的第一个参数</span>  <span class="token comment" spellcheck="true">//preValue值取决于你回调函数中的return值</span>  <span class="token comment" spellcheck="true">//如果是 return 100 ，那么每次执行回调函数，preValue值都是100</span>  <span class="token keyword">return</span> preValue <span class="token operator">+</span> n  <span class="token comment" spellcheck="true">//第一次 preValue:0  n:20  </span>  <span class="token comment" spellcheck="true">//第二次 preValue:0+20 n:40</span>  <span class="token comment" spellcheck="true">//第三次 preValue:20+40 n:60</span>  <span class="token comment" spellcheck="true">//第四次 preValue:60+60 n:80</span>  <span class="token comment" spellcheck="true">//此时n是最后一个元素了，函数结束运行，返回preValue+n的值，也就是最后一次运行60+60+80=200</span>  <span class="token comment" spellcheck="true">//也就是这三个函数运行后最终结果total = 200</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//简写为指数函数</span><span class="token keyword">let</span> total <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>n <span class="token operator">=</span><span class="token operator">></span> n <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>n <span class="token operator">=</span><span class="token operator">></span> n <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token punctuation">(</span>pervue<span class="token punctuation">,</span> n<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> pervue <span class="token operator">+</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//最后结果也是为total = 200</span></code></pre><blockquote><p>感谢您的观看。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Layer弹框组件</title>
      <link href="/2019/11/24/layer-dan-kuang-zu-jian/"/>
      <url>/2019/11/24/layer-dan-kuang-zu-jian/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Layui是经典模块化前端框架， 由职业前端倾情打造，面向全层次的前后端开发者，低门槛开箱即用的前端 UI 解决方案 ，本文章主要讲解Layui里的独立弹框组件Layer。</p></blockquote><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p><em>layer</em>是一款近年来备受青睐的web弹层组件，她具备全方位的解决方案，致力于服务各水平段的开发人员，您的页面会轻松地拥有丰富友好的操作体验。</p><p>在与同类组件的比较中，<em>layer<em>总是能轻易获胜。她尽可能地在以更少的代码展现更强健的功能，且格外注重性能的提升、易用和实用性，正因如此，越来越多的开发者将媚眼投上了</em>layer<em>（已被**</em>10206621**<em>人次关注）。</em>layer</em> 甚至兼容了包括 IE6 在内的所有主流浏览器。她数量可观的接口，使得您可以自定义太多您需要的风格，每一种弹层模式各具特色，广受欢迎。当然，这种“王婆卖瓜”的陈述听起来总是有点难受，因此你需要进一步了解她是否真的如你所愿。</p><p><em>layer</em> 采用 MIT 开源许可证，<em>将会永久性提供无偿服务*。因着数年的坚持维护，截至到2017年9月13日，已运用在超过 *30万</em> 家 Web 平台，其中不乏众多知名大型网站。目前 layer 已经成为国内乃至全世界最多人使用的 Web 弹层解决方案，并且她仍在与 Layui 一并高速发展。<a href="http://fly.layui.com/" target="_blank" rel="noopener"><em>Fly</em></a>社区。</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><blockquote><p>Layer在作为一个独立的组件使用时 你需要在你的页面引入<strong>jQuery1.8</strong>以上的任意版本，并引入<strong>layer.js</strong>。 </p></blockquote><blockquote><p><a href="layer.zip">点击下载layer组件</a> </p><p><a href="jquery.zip">点击下载jQuery.js</a></p></blockquote><p><em>把下载的layer压缩包解压到项目文件夹中，只引用其根目录的<strong>layer.js</strong>即可</em></p><pre class=" language-html"><code class="language-html">//引入好layer.js和jquery.js后，直接用即可<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>../layer/layer.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>../js/jquery-3.4.1.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script language-javascript">layer<span class="token punctuation">.</span><span class="token function">msg</span><span class="token punctuation">(</span><span class="token string">'hello'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span></code></pre><h3 id="基础参数"><a href="#基础参数" class="headerlink" title="基础参数"></a>基础参数</h3><blockquote><p> 我们提到的基础参数主要指调用方法时用到的配置项，如：<em>layer.open({content: ‘’})*</em>layer.msg(‘’, {time: 3})<em>等，其中的content和time即是基础参数，以键值形式存在，基础参数</em>可合理应用于任何层类型中*，您不需要所有都去配置，大多数都是可选的。而其中的layer.open、layer.msg就是内置方法。注意，从2.3开始，无需通过layer.config来加载拓展模块。</p></blockquote><h4 id="type-基本层类型"><a href="#type-基本层类型" class="headerlink" title="type - 基本层类型"></a>type - 基本层类型</h4><p>类型：Number，默认：0</p><p>layer提供了5种层类型。可传入的值有：<em>0</em>（信息框，默认）<em>1</em>（页面层）<em>2</em>（iframe层）<em>3</em>（加载层）<em>4</em>（tips层）。 若你采用<code>layer.open({type: 1})</code>方式调用，则type为必填项（信息框除外）</p><h4 id="title-标题"><a href="#title-标题" class="headerlink" title="title - 标题"></a>title - 标题</h4><p>类型：String/Array/Boolean，默认：’信息’</p><p>title支持三种类型的值，若你传入的是普通的字符串，如<code>title :&#39;我是标题&#39;</code>，那么只会改变标题文本；若你还需要自定义标题区域样式，那么你可以<code>title: [&#39;文本&#39;, &#39;font-size:18px;&#39;]</code>，数组第二项可以写任意css样式；如果你不想显示标题栏，你可以<code>title: false</code></p><h4 id="content-内容"><a href="#content-内容" class="headerlink" title="content - 内容"></a>content - 内容</h4><p>类型：String/DOM/Array，默认：’ ‘</p><p>content可传入的值是灵活多变的，不仅可以传入普通的html内容，还可以指定DOM，更可以随着type的不同而不同。譬如：</p><pre class=" language-js"><code class="language-js"><span class="token operator">/</span><span class="token operator">!</span><span class="token operator">*</span> 如果是页面层 <span class="token operator">*</span><span class="token operator">/</span>layer<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  type<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span>   <span class="token comment" spellcheck="true">//这里content是一个普通的String</span>  content<span class="token punctuation">:</span> <span class="token string">'传入任意的文本或html'</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>layer<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  type<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span>  <span class="token comment" spellcheck="true">//这里content是一个DOM，注意：最好该元素要存放在body最外层，否则可能被其它的相对元素所影响</span>  content<span class="token punctuation">:</span> <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">'#id'</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//Ajax获取</span>$<span class="token punctuation">.</span><span class="token function">post</span><span class="token punctuation">(</span><span class="token string">'url'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">{</span>  layer<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token punctuation">{</span>    type<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">//注意，如果str是object，那么需要字符拼接。</span>    content<span class="token punctuation">:</span> str   <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">/</span><span class="token operator">!</span><span class="token operator">*</span> 如果是iframe层 <span class="token operator">*</span><span class="token operator">/</span>layer<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  type<span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">,</span>   <span class="token comment" spellcheck="true">//这里content是一个URL，如果你不想让iframe出现滚动条，你还可以content:</span>                                        <span class="token punctuation">[</span><span class="token string">'http://sentsin.com'</span><span class="token punctuation">,</span> <span class="token string">'no'</span><span class="token punctuation">]</span>  content<span class="token punctuation">:</span> <span class="token string">'http://sentsin.com'</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">/</span><span class="token operator">!</span><span class="token operator">*</span> 如果是用layer<span class="token punctuation">.</span>open执行tips层 <span class="token operator">*</span><span class="token operator">/</span>layer<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  type<span class="token punctuation">:</span> <span class="token number">4</span><span class="token punctuation">,</span>  <span class="token comment" spellcheck="true">//数组第二项即吸附元素选择器或者DOM    </span>  content<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'内容'</span><span class="token punctuation">,</span> <span class="token string">'#id'</span><span class="token punctuation">]</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        </code></pre><h4 id="skin-样式类名"><a href="#skin-样式类名" class="headerlink" title="skin - 样式类名"></a>skin - 样式类名</h4><p>类型：String，默认：’ ‘</p><p>skin不仅允许你传入layer内置的样式class名，还可以传入您自定义的class名。这是一个很好的切入点，意味着你可以借助skin轻松完成不同的风格定制。目前layer内置的skin有：<code>layui-layer-lan</code>, <code>layui-layer-molv</code>，以下是一个自定义风格的简单例子</p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">//单个使用</span>layer<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  skin<span class="token punctuation">:</span> <span class="token string">'demo-class'</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//全局使用。即所有弹出层都默认采用，但是单个配置skin的优先级更高</span>layer<span class="token punctuation">.</span><span class="token function">config</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  skin<span class="token punctuation">:</span> <span class="token string">'demo-class'</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//CSS </span>body <span class="token punctuation">.</span>demo<span class="token operator">-</span><span class="token keyword">class</span> <span class="token class-name"><span class="token punctuation">.</span>layui</span><span class="token operator">-</span>layer<span class="token operator">-</span>title<span class="token punctuation">{</span>background<span class="token punctuation">:</span>#c00<span class="token punctuation">;</span> color<span class="token punctuation">:</span>#fff<span class="token punctuation">;</span> border<span class="token punctuation">:</span> none<span class="token punctuation">;</span><span class="token punctuation">}</span>body <span class="token punctuation">.</span>demo<span class="token operator">-</span><span class="token keyword">class</span> <span class="token class-name"><span class="token punctuation">.</span>layui</span><span class="token operator">-</span>layer<span class="token operator">-</span>btn<span class="token punctuation">{</span>border<span class="token operator">-</span>top<span class="token punctuation">:</span>1px solid #E9E7E7<span class="token punctuation">}</span>body <span class="token punctuation">.</span>demo<span class="token operator">-</span><span class="token keyword">class</span> <span class="token class-name"><span class="token punctuation">.</span>layui</span><span class="token operator">-</span>layer<span class="token operator">-</span>btn a<span class="token punctuation">{</span>background<span class="token punctuation">:</span>#<span class="token number">333</span><span class="token punctuation">;</span><span class="token punctuation">}</span>body <span class="token punctuation">.</span>demo<span class="token operator">-</span><span class="token keyword">class</span> <span class="token class-name"><span class="token punctuation">.</span>layui</span><span class="token operator">-</span>layer<span class="token operator">-</span>btn <span class="token punctuation">.</span>layui<span class="token operator">-</span>layer<span class="token operator">-</span>btn1<span class="token punctuation">{</span>background<span class="token punctuation">:</span>#<span class="token number">999</span><span class="token punctuation">;</span><span class="token punctuation">}</span>…加上body是为了保证优先级。你可以借助Chrome调试工具，定义更多样式控制层更多的区域。    </code></pre><h4 id="area-宽高"><a href="#area-宽高" class="headerlink" title="area - 宽高"></a>area - 宽高</h4><p>类型：String/Array，默认：’auto’</p><p>在默认状态下，layer是宽高都自适应的，但当你只想定义宽度时，你可以<code>area: &#39;500px&#39;</code>，高度仍然是自适应的。当你宽高都要定义时，你可以<code>area: [&#39;500px&#39;, &#39;300px&#39;]</code></p><h4 id="offset-坐标"><a href="#offset-坐标" class="headerlink" title="offset - 坐标"></a>offset - 坐标</h4><p>类型：String/Array，默认：垂直水平居中</p><p>offset默认情况下不用设置。但如果你不想垂直水平居中，你还可以进行以下赋值：</p><table><thead><tr><th>值</th><th>备注</th></tr></thead><tbody><tr><td><code>offset: &#39;auto&#39;</code></td><td>默认坐标，即垂直水平居中</td></tr><tr><td><code>offset: &#39;100px&#39;</code></td><td>只定义top坐标，水平保持居中</td></tr><tr><td><code>offset: [&#39;100px&#39;, &#39;50px&#39;]</code></td><td>同时定义top、left坐标</td></tr><tr><td><code>offset: &#39;t&#39;</code></td><td>快捷设置顶部坐标</td></tr><tr><td><code>offset: &#39;r&#39;</code></td><td>快捷设置右边缘坐标</td></tr><tr><td><code>offset: &#39;b&#39;</code></td><td>快捷设置底部坐标</td></tr><tr><td><code>offset: &#39;l&#39;</code></td><td>快捷设置左边缘坐标</td></tr><tr><td><code>offset: &#39;lt&#39;</code></td><td>快捷设置左上角</td></tr><tr><td><code>offset: &#39;lb&#39;</code></td><td>快捷设置左下角</td></tr><tr><td><code>offset: &#39;rt&#39;</code></td><td>快捷设置右上角</td></tr><tr><td><code>offset: &#39;rb&#39;</code></td><td>快捷设置右下角</td></tr></tbody></table><h4 id="icon-图标-信息框和加载层的私有参数"><a href="#icon-图标-信息框和加载层的私有参数" class="headerlink" title="icon - 图标.信息框和加载层的私有参数"></a>icon - 图标.信息框和加载层的私有参数</h4><p>类型：Number，默认：-1（信息框）/0（加载层）</p><p>信息框默认不显示图标。当你想显示图标时，默认皮肤可以传入<em>0-6</em>如果是加载层，可以传入<em>0-2</em>。如：</p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">//eg1</span>layer<span class="token punctuation">.</span><span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'酷毙了'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>icon<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//eg2</span>layer<span class="token punctuation">.</span><span class="token function">msg</span><span class="token punctuation">(</span><span class="token string">'不开心。。'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>icon<span class="token punctuation">:</span> <span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//eg3</span>layer<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//风格1的加载</span></code></pre><h4 id="btn-按钮"><a href="#btn-按钮" class="headerlink" title="btn - 按钮"></a>btn - 按钮</h4><p>类型：String/Array，默认：’确认’</p><p>信息框模式时，btn默认是一个确认按钮，其它层类型则默认不显示，加载层和tips层则无效。当您只想自定义一个按钮时，你可以<code>btn: &#39;我知道了&#39;</code>，当你要定义两个按钮时，你可以<code>btn: [&#39;yes&#39;, &#39;no&#39;]</code>。当然，你也可以定义更多按钮，比如：<code>btn: [&#39;按钮1&#39;, &#39;按钮2&#39;, &#39;按钮3&#39;, …]</code>，按钮1的回调是yes，而从按钮2开始，则回调为<code>btn2: function(){}</code>，以此类推。如：</p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">//eg1       </span>layer<span class="token punctuation">.</span><span class="token function">confirm</span><span class="token punctuation">(</span><span class="token string">'纳尼？'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>  btn<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'按钮一'</span><span class="token punctuation">,</span> <span class="token string">'按钮二'</span><span class="token punctuation">,</span> <span class="token string">'按钮三'</span><span class="token punctuation">]</span> <span class="token comment" spellcheck="true">//可以无限个按钮</span>  <span class="token punctuation">,</span>btn3<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span>index<span class="token punctuation">,</span> layero<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//按钮【按钮三】的回调</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span>index<span class="token punctuation">,</span> layero<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//按钮【按钮一】的回调</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//按钮【按钮二】的回调</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//eg2</span>layer<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  content<span class="token punctuation">:</span> <span class="token string">'test'</span>  <span class="token punctuation">,</span>btn<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'按钮一'</span><span class="token punctuation">,</span> <span class="token string">'按钮二'</span><span class="token punctuation">,</span> <span class="token string">'按钮三'</span><span class="token punctuation">]</span>  <span class="token punctuation">,</span>yes<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span>index<span class="token punctuation">,</span> layero<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//按钮【按钮一】的回调</span>  <span class="token punctuation">}</span>  <span class="token punctuation">,</span>btn2<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span>index<span class="token punctuation">,</span> layero<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//按钮【按钮二】的回调</span>    <span class="token comment" spellcheck="true">//return false 开启该代码可禁止点击该按钮关闭</span>  <span class="token punctuation">}</span>  <span class="token punctuation">,</span>btn3<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span>index<span class="token punctuation">,</span> layero<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//按钮【按钮三】的回调</span>    <span class="token comment" spellcheck="true">//return false 开启该代码可禁止点击该按钮关闭</span>  <span class="token punctuation">}</span>  <span class="token punctuation">,</span>cancel<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">//右上角关闭回调</span>    <span class="token comment" spellcheck="true">//return false 开启该代码可禁止点击该按钮关闭</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><blockquote><p>以上是几个常用的layer属性，如果想深入了解请移步<a href="https://www.layui.com/doc/modules/layer.html" target="_blank" rel="noopener">官方文档</a>。</p></blockquote><h3 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h3><blockquote><p> 获得 layer 文件包后，解压并将 <em>layer 整个文件夹<em>（不要拆分结构） 存放到你项目的任意目录，使用时，</em>只需引入 layer.js 即可。</em> 下面是一个入门示例： </p></blockquote><style>    button{        width: 20%;        height: 35px;        border: none;        background-color: #009688;        color: #FFFFFF;        outline: none;    }    button:hover{        opacity: 0.8;        cursor: pointer;    }</style><script src="/libs/layer/layer.js"></script><pre class=" language-pre"><code class="language-pre"><script type="text/html" style='display:block'><!DOCTYPE html><html lang="zh"><head>    <meta charset="UTF-8" />    <meta name="viewport" content="width=device-width, initial-scale=1.0" />    <meta http-equiv="X-UA-Compatible" content="ie=edge" />    <title>Layer演示</title></head><body>    <!-- 你必须先引入jQuery1.8或以上版本 -->    <script src="jQuery地址"></script>    &lt;script src="layer.js地址"></script></script>&lt;script&gt;<br>    //弹出一个提示层    $('#test1').on('click',function(){        layer.msg('hello');     });<button id="test1">运行上述例子</button><br>    //弹出一个页面层    $('#test2').on('click', function(){          layer.open({         type: 1,          area: ['600px', '360px'],          shadeClose: true, //点击遮罩关闭          content: '\<\div style="padding:20px;">自定义内容\<\/div>'         });         });<button id="test2">运行上述例子</button><br>    //弹出一个询问层    $('#test3').on('click', function(){           layer.confirm('您是如何看待前端开发？', {          btn: ['重要','奇葩'] //按钮        }, function(){         layer.msg('的确很重要', {icon: 1});         }, function(){           layer.msg('也可以这样', {             time: 20000, //20s后自动关闭              btn: ['明白了', '知道了']         });       });     });<button id="test3">运行上述例子</button><br>    //弹出一个loading层    $('#test4').on('click', function(){        var ii = layer.load();        //此处用setTimeout演示ajax的回调           setTimeout(function(){             layer.close(ii);           }, 1000);    });<button id="test4">运行上述例子</button><br>    //弹出一个tips层    $('#test5').on('click', function(){       layer.tips('Hello tips!', '#test5');    });<button id="test5">运行上述例子</button>&lt;&frasl;script&gt;<br><span>当你对此建立了一定的初始，你应该去详看API手册了。</span><br>&lt;&frasl;body&gt;&lt;&frasl;html&gt;</code></pre><blockquote><p>以上只是举出简单的几个例子，如想深入了解请移步<a href="https://www.layui.com/doc/modules/layer.html" target="_blank" rel="noopener">官方文档</a>。</p></blockquote><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>该Layer组件具有非常丰富的弹框样式，还可以下载外部的弹框表情，以及自己制作自己的DIY表情。是一个值得去花时间研究的组件。</p><blockquote><p>感谢您的观看！</p></blockquote><script src="/libs/layer/layertest.js"></script>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Layui </tag>
            
            <tag> Layer </tag>
            
            <tag> jQuery </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JSP内置对象（三）</title>
      <link href="/2019/11/10/jsp-nei-zhi-dui-xiang-3/"/>
      <url>/2019/11/10/jsp-nei-zhi-dui-xiang-3/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文章部分参考<a href="https://blog.csdn.net/pan_junbiao/article/details/87916435" target="_blank" rel="noopener">https://blog.csdn.net/pan_junbiao/article/details/87916435</a></p></blockquote><blockquote><p><a href="/2019/11/01/jsp-nei-zhi-dui-xiang-1">点击跳转JSP内置对象（一）</a></p><p><a href="/2019/11/10/jsp-nei-zhi-dui-xiang-2">点击跳转JSP内置对象（二）</a></p></blockquote><p>JSP提供了由容器实现和管理的内置对象，也可以称之为隐含对象，由于JSP使用Java作为脚本语言，所以JSP将具有强大的对象处理能力，并且可以动态创建Web页面内容。但Java语法在使用一个对象前，需要先实例化这个对象，这其实是一件比较烦琐的事情。JSP为了简化开发，提供了一些内置对象，用来实现很多JSP应用。在使用JSP内置对象时，不需要先定义这些对象，直接使用即可。</p><blockquote><p> 在JSP中一共预先定义了<strong>9</strong>个这样的对象，分别为<code>request</code>、<code>response</code>、<code>session</code>、<code>application</code>、<code>out</code>、<code>pageContext</code>、<code>config</code>、<code>pag</code>和<code>exception</code>。 </p></blockquote><table><thead><tr><th>内置对象</th><th>类型</th></tr></thead><tbody><tr><td><code>request</code></td><td>javax.servlet.http.HttpServletRequest</td></tr><tr><td><code>response</code></td><td>javax.servlet.http.HttpServletResponse</td></tr><tr><td><code>session</code></td><td>javax.servlet.http.HttpSession</td></tr><tr><td><code>application</code></td><td>javax.servlet.ServletContext</td></tr><tr><td><code>out</code></td><td>javax.servlet.jsp.JspWriter</td></tr><tr><td><code>pageContext</code></td><td>javax.servlet.jsp.PageContext</td></tr><tr><td><code>config</code></td><td>javax.servlet.ServletConfig</td></tr><tr><td><code>page</code></td><td>javax.servlet.jsp.JspPage</td></tr><tr><td><code>exception</code></td><td>javax.servlet.jsp.JspException</td></tr></tbody></table><h3 id="七、读取web-xml配置信息的config对象"><a href="#七、读取web-xml配置信息的config对象" class="headerlink" title="七、读取web.xml配置信息的config对象"></a>七、读取web.xml配置信息的config对象</h3><blockquote><p> <code>config</code>对象主要用于取得服务器的配置信息。当一个<code>Servlet</code>初始化时，容器把某些信息通过<code>config</code>对象传递给这个<code>Servlet</code>。开发者可以在web.xml文件中为应用程序环境中的<code>Servlet</code>程序和JSP页面提供初始化参数。 </p></blockquote><p><code>config</code>对象的常用方法如下：</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>getServletContext()</code></td><td>获取<code>Servlet</code>上下文。</td></tr><tr><td><code>getServletName()</code></td><td>获取<code>Servlet</code>服务器名。</td></tr><tr><td><code>getInitParameterNames()</code></td><td>获取服务器所有初始化参数名称。</td></tr><tr><td><code>getInitParameter(String name)</code></td><td>获取服务器中<code>name</code>参数的初始值。</td></tr></tbody></table><h3 id="八、应答或请求的page对象"><a href="#八、应答或请求的page对象" class="headerlink" title="八、应答或请求的page对象"></a>八、应答或请求的page对象</h3><blockquote><p> <code>page</code>对象代表JSP本身，只有在JSP页面内才是合法的。<code>page</code>对象本质上是包含当前<code>Servlet</code>接口引用的变量，可以看作是<code>this</code>关键字的别名。 </p></blockquote><p><code>page</code>对象的常用方法如下： </p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>getClass()</code></td><td>返回当前<code>Object</code>的类。</td></tr><tr><td><code>hashCode()</code></td><td>返回该<code>Object</code>的哈希代码。</td></tr><tr><td><code>toString()</code></td><td>把该<code>Object</code>类转换成字符串。</td></tr><tr><td><code>equals(Object obj)</code></td><td>比较该对象和指定的对象是否相等。</td></tr></tbody></table><p> <strong>示例：</strong>创建pageTest.jsp文件，在该文件中调用<code>page</code>对象的各方法，并显示返回结果。 </p><pre class=" language-jsp"><code class="language-jsp"><script type="text/html" style='display:block'><%@ page language="java" contentType="text/html; charset=UTF-8"    pageEncoding="UTF-8"%><!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"><html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>page对象的使用</title></head><body><%!    Object object;     //声明一个Object型的变量        %><ul>    <li>getClass()方法的返回值:<%=page.getClass()%></li>    <li>hashCode()方法的返回值:<%=page.hashCode()%></li>    <li>toString()方法的返回值:<%=page.toString()%></li>    <li>与Object对象比较的返回值:<%=page.equals(object)%></li>    <li>与this对象比较的返回值:<%=page.equals(this)%></li></ul></body></html></script></code></pre><p><strong>执行结果：</strong></p><img src="/blog//czongz.gitee.io/blog/2019/11/10/jsp-nei-zhi-dui-xiang-3/1.png"><h3 id="九、获取异常信息的exception对象"><a href="#九、获取异常信息的exception对象" class="headerlink" title="九、获取异常信息的exception对象"></a>九、获取异常信息的exception对象</h3><blockquote><p><code>exception</code>对象用来处理JSP文件执行时发生的所有错误和异常，只有在page指令中设置<code>isErrorPage</code>属性值为<code>true</code>的页面中才可以被使用，在一般的JSP页面中使用该对象将无法编译JSP文件。<code>exception</code>对象几乎定义了所有异常情况，在Java程序中，可以使用<code>try...catch</code>关键字来处理异常情况，如果在JSP页面中出现没有捕获到的异常，就会生成<code>exception</code>对象，并把<code>exception</code>对象传送到在<code>page</code>指令中定义的错误页面中，然后在错误页面中处理相应的<code>exception</code>对象。</p></blockquote><p><code>exception</code>对象的常用方法如下： </p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>getMessage()</code></td><td>返回<code>exception</code>对象的异常信息字符串。</td></tr><tr><td><code>getLocalizedMessage()</code></td><td>返回本地化的异常错误。</td></tr><tr><td><code>toString()</code></td><td>返回关于异常错误的简单信息描述。</td></tr><tr><td><code>fillInStackTrace()</code></td><td>重写异常错误的栈行轨迹。</td></tr></tbody></table><p><strong>示例：</strong>使用<code>exception</code>对象获取异常信息。</p><p>（1）创建index.jsp文件，在该文件中，首先在<code>page</code>指令中定义<code>errorPage</code>属性值为error.jsp，即指定显示异常信息的页面。</p><pre class=" language-jsp"><code class="language-jsp"><script type="text/html" style='display:block'><%@ page language="java" contentType="text/html; charset=UTF-8"    //设置errorPage属性值。    pageEncoding="UTF-8" errorPage="error.jsp"    %><!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"><html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>使用exception对象获取异常信息</title></head><body><%    //保存单价到request范围内的变量price中    request.setAttribute("price", "12.5");        //获取单价，并转换为float类型(这里的‘元’是String类型无法转换Float)    float price = Float.parseFloat(request.getAttribute("price").toString());      out.print("price的值为："+price);%></body></html></script></code></pre><p> （2）编写error.jsp文件，将该页面的<code>page</code>指令的<code>isErrorPage</code>属性值设置为<code>true</code>，并且输出异常信息。 </p><pre class=" language-jsp"><code class="language-jsp"><script type="text/html" style='display:block'><%@ page language="java" contentType="text/html; charset=UTF-8"    //设置isErrorPage属性值为'true'    pageEncoding="UTF-8" isErrorPage="true"    %><!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"><html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>错误提示页面</title></head><body>错误提示为：<%=exception.getMessage() %></body></html></script></code></pre><p><strong>执行结果：</strong></p><img src="/blog//czongz.gitee.io/blog/2019/11/10/jsp-nei-zhi-dui-xiang-3/2.png"><p><strong>如果去掉”元”则代表没有错误，就不会跳转error.jsp，执行结果：</strong></p><img src="/blog//czongz.gitee.io/blog/2019/11/10/jsp-nei-zhi-dui-xiang-3/3.png"><blockquote><p>感谢您的观看！</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JSP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JSP内置对象（二）</title>
      <link href="/2019/11/10/jsp-nei-zhi-dui-xiang-2/"/>
      <url>/2019/11/10/jsp-nei-zhi-dui-xiang-2/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文章部分参考<a href="https://blog.csdn.net/pan_junbiao/article/details/87916435" target="_blank" rel="noopener">https://blog.csdn.net/pan_junbiao/article/details/87916435</a></p></blockquote><blockquote><p><a href="/2019/11/01/jsp-nei-zhi-dui-xiang-1">点击跳转JSP内置对象（一）</a></p><p><a href="/2019/11/10/jsp-nei-zhi-dui-xiang-3">点击跳转JSP内置对象（三）</a></p></blockquote><p>JSP提供了由容器实现和管理的内置对象，也可以称之为隐含对象，由于JSP使用Java作为脚本语言，所以JSP将具有强大的对象处理能力，并且可以动态创建Web页面内容。但Java语法在使用一个对象前，需要先实例化这个对象，这其实是一件比较烦琐的事情。JSP为了简化开发，提供了一些内置对象，用来实现很多JSP应用。在使用JSP内置对象时，不需要先定义这些对象，直接使用即可。</p><blockquote><p> 在JSP中一共预先定义了<strong>9</strong>个这样的对象，分别为<code>request</code>、<code>response</code>、<code>session</code>、<code>application</code>、<code>out</code>、<code>pageContext</code>、<code>config</code>、<code>pag</code>和<code>exception</code>。 </p></blockquote><table><thead><tr><th>内置对象</th><th>类型</th></tr></thead><tbody><tr><td><code>request</code></td><td>javax.servlet.http.HttpServletRequest</td></tr><tr><td><code>response</code></td><td>javax.servlet.http.HttpServletResponse</td></tr><tr><td><code>session</code></td><td>javax.servlet.http.HttpSession</td></tr><tr><td><code>application</code></td><td>javax.servlet.ServletContext</td></tr><tr><td><code>out</code></td><td>javax.servlet.jsp.JspWriter</td></tr><tr><td><code>pageContext</code></td><td>javax.servlet.jsp.PageContext</td></tr><tr><td><code>config</code></td><td>javax.servlet.ServletConfig</td></tr><tr><td><code>page</code></td><td>javax.servlet.jsp.JspPage</td></tr><tr><td><code>exception</code></td><td>javax.servlet.jsp.JspException</td></tr></tbody></table><h3 id="四、application对象"><a href="#四、application对象" class="headerlink" title="四、application对象"></a>四、application对象</h3><blockquote><p><code>application</code>对象用于保存所有应用中的共有数据。它在服务器启动时自动创建，在服务器停止时销毁。当<code>application</code>对象没有被销毁时，所有用户都可以共享该<code>application</code>对象。与<code>session</code>对象相比，<code>application</code>对象的生命周期更长，类似于系统的“<strong>全局变量</strong>”。</p></blockquote><p><code>application</code>对象的常用方法： </p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>String getInitParameter(String name)</code></td><td>获取已命名的应用程序初始化参数值。</td></tr><tr><td><code>Enumeration&lt;String&gt; getInitParameterNames()</code></td><td>获取所有已定义的应用程序初始化参数名的枚举。</td></tr><tr><td><code>Enumeration&lt;String&gt; getAttributeNames()</code></td><td>获取所有<code>application</code>对象使用的属性名。</td></tr><tr><td><code>Object getAttribute(String name)</code></td><td>从<code>application</code>对象中获取指定对象名。</td></tr><tr><td><code>void setAttribute(String key,Object obj)</code></td><td>使用指定名称和指定对象在<code>application</code>对象中进行关联。</td></tr><tr><td><code>void removeAttribute(String name)</code></td><td>从<code>application</code>对象中去掉指定名称的属性。</td></tr></tbody></table><h4 id="4-1-访问应用程序初始化参数"><a href="#4-1-访问应用程序初始化参数" class="headerlink" title="4.1 访问应用程序初始化参数"></a>4.1 访问应用程序初始化参数</h4><blockquote><p> <code>application</code>对象提供了对应用程序初始化参数进行访问的方法。应用程序初始化参数在web.xml文件中进行设置，web.xml文件位于Web应用所在目录下的WEB-INF子目录中。在web.xml文件中通过<code>&lt;context-param&gt;</code>标记配置应用程序初始化参数。 </p></blockquote><p> <strong>示例：</strong>在web.xml文件中配置连接MySQL数据库所需的<code>url</code>参数。 </p><pre class=" language-xml"><code class="language-xml"> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>context-param</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>param-name</span><span class="token punctuation">></span></span>url<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>param-name</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>param-value</span><span class="token punctuation">></span></span>jdbc:mysql://127.0.0.1:3306/db_database<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>param-value</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>context-param</span><span class="token punctuation">></span></span></code></pre><p>*<em><code>application</code>对象提供了两种访问应用程序初始化参数的方法。 *</em></p><h5 id="4-1-1-getInitParameter-String-name-方法"><a href="#4-1-1-getInitParameter-String-name-方法" class="headerlink" title="4.1.1 getInitParameter(String name)方法"></a>4.1.1 getInitParameter(String name)方法</h5><blockquote><p> <code>String getInitParameter(String name)</code>方法用于获取已命名的应用程序初始化参数值。 </p></blockquote><p> <strong>示例：</strong>获取上面web.xml文件中配置的<code>url</code>参数的值。 </p><pre class=" language-jsp"><code class="language-jsp"><%    String url = application.getInitParameter("url");%></code></pre><h5 id="4-1-2-getInitParameterNames-方法"><a href="#4-1-2-getInitParameterNames-方法" class="headerlink" title="4.1.2 getInitParameterNames( )方法"></a>4.1.2 getInitParameterNames( )方法</h5><blockquote><p><code>Enumeration&lt;String&gt; getInitParameterNames()</code>方法获取所有已定义的应用程序初始化参数名的枚举。 </p></blockquote><p> <strong>示例：</strong>使用<code>getInitParameterNames()</code>方法获取web.xml文件中定义的全部应用程序初始化参数，并通过循环输出。 </p><pre class=" language-jsp"><code class="language-jsp"><%@ page import="java.util.*" %><%     //获取全部初始化参数    Enumeration<String> enume = application.getInitParameterNames();      while(enume.hasMoreElements())    {        //获取参数名        String name = enume.nextElement();              //获取参数值        String value = application.getInitParameter(name);          out.println(name + "：");  //输出参数名        out.println(value);        //输出参数值    }%></code></pre><h4 id="4-2-管理应用程序环境属性"><a href="#4-2-管理应用程序环境属性" class="headerlink" title="4.2 管理应用程序环境属性"></a>4.2 管理应用程序环境属性</h4><blockquote><p> 与<code>session</code>对象相同，也可以在<code>application</code>对象中设置属性。与<code>session</code>对象不同的是，<code>session</code>只是在当前客户的会话范围内有效，当超过保存时间，<code>session</code>对象就被收回；而<code>application</code>对象在整个应用区域中都有效。 </p></blockquote><pre class=" language-jsp"><code class="language-jsp"><%     //保存application对象        application.setAttribute("UserName", "指人猫的博客");               //获取application对象    String userName = application.getAttribute("UserName").toString(); %></code></pre><h3 id="五、out对象"><a href="#五、out对象" class="headerlink" title="五、out对象"></a>五、out对象</h3><blockquote><p> <code>out</code>对象用于在Web浏览器内输出信息，并且管理应用服务器上的输出缓冲区。在使用<code>out</code>对象输出数据时，可以对数据缓冲区进行操作，及时清除缓冲区中的残余数据，为其他的输出让出缓冲空间。待数据输出完毕后，要及时关闭输出流。 </p></blockquote><h4 id="5-1-向客户端输出数据"><a href="#5-1-向客户端输出数据" class="headerlink" title="5.1 向客户端输出数据"></a>5.1 向客户端输出数据</h4><blockquote><p><code>out</code>对象一个最基本的应用就是向客户端浏览器输出信息。<code>out</code>对象可以输出各种数据类型的数据，在输出非字符串类型的数据时，会自动转换为字符串进行输出。<code>out</code>对象提供了<code>print()</code>和<code>println()</code>两种向页面中输出信息的方法。 </p></blockquote><h5 id="5-1-1-print-方法"><a href="#5-1-1-print-方法" class="headerlink" title="5.1.1 print( )方法"></a>5.1.1 print( )方法</h5><p> <strong>示例：</strong>通过两种方式向客户端浏览器输出文字。 </p><pre class=" language-jsp"><code class="language-jsp"><%    out.print("您好，指人猫的博客");%><%= "您好，指人猫的博客" %></code></pre><h5 id="5-1-2-println-方法"><a href="#5-1-2-println-方法" class="headerlink" title="5.1.2 println( )方法"></a>5.1.2 println( )方法</h5><blockquote><p><code>println()</code>方法也可以用于向客户端浏览器输出信息，该方法输出内容后，还输出一个换行符。 </p></blockquote><p> <strong>示例：</strong>使用<code>println()</code>方法向客户端浏览器输出文字。 </p><pre class=" language-jsp"><code class="language-jsp"><script type="text/html" style='display:block'><pre><%    out.println("<b>使用println()方法向客户端浏览器输出文字：</b>");    out.println("您好！");    out.println("欢迎访问 指人猫的博客");    out.println("博客地址：https://czongz.github.io");%></pre></script></code></pre><p> <strong>说明：</strong>使用<code>println()</code>方法输出内容要有换行的效果，需要同时使用HTML的<code>&lt;pre&gt;</code>标记括起来，否则无法显示换行效果。 </p><p><strong>执行结果（用<code>&lt;pre&gt;</code>标签）：</strong></p><img src="/blog//czongz.gitee.io/blog/2019/11/10/jsp-nei-zhi-dui-xiang-2/1.png"><p><strong>执行结果（未用<code>&lt;pre&gt;</code>）标签：</strong></p><img src="/blog//czongz.gitee.io/blog/2019/11/10/jsp-nei-zhi-dui-xiang-2/2.png"><h4 id="5-2-管理响应缓冲"><a href="#5-2-管理响应缓冲" class="headerlink" title="5.2 管理响应缓冲"></a>5.2 管理响应缓冲</h4><blockquote><p><code>out</code>对象的另一个比较重要的功能就是对缓冲区进行管理。通过调用<code>out</code>对象的<code>clear()</code>方法可以清除缓冲区的内容。这类似于重置响应流，以便重新开始操作。如果响应已经提交，则会有产生<code>IOException</code>异常的负作用。<code>out</code>对象还提供了另一种清除缓冲区内容的方法，那就是<code>clearBuffer()</code>方法，通过该方法可以清除缓冲区的“当前”内容，而且即使内容已经提交给客户端，也能够访问该方法。除了这两个方法外，<code>out</code>对象还提供了其他用于管理缓冲区的方法。</p></blockquote><p><code>out</code>对象用于管理缓冲区的方法如下：</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>clear()</code></td><td>清除缓冲区中的内容。</td></tr><tr><td><code>clearBuffer()</code></td><td>清除当前缓冲区中的内容。</td></tr><tr><td><code>flush()</code></td><td>刷新流。</td></tr><tr><td><code>isAutoFlush()</code></td><td>检测当前缓冲区已满时是自动清空，还是抛出异常。</td></tr><tr><td><code>getBufferSize()</code></td><td>获取缓冲区的大小。</td></tr></tbody></table><h3 id="六、获取会话范围的pageContext对象"><a href="#六、获取会话范围的pageContext对象" class="headerlink" title="六、获取会话范围的pageContext对象"></a>六、获取会话范围的pageContext对象</h3><blockquote><p>获取页面上下文的<code>pageContext</code>对象是一个比较特殊的对象，通过它可以获取JSP页面的<code>request</code>、<code>response</code>、<code>session</code>、<code>out</code>、<code>exception</code>等对象。<code>pageContext</code>对象的创建和初始化都是由容器来完成的，JSP页面中可以直接使用<code>pageContext</code>对象。</p></blockquote><p><code>pageContext</code>对象的常用方法： </p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>forward(String relativeUrlPath)</code></td><td>把页面转发给另一个页面。</td></tr><tr><td><code>getAttribute(String name)</code></td><td>获取参数值。</td></tr><tr><td><code>getAttributeNamesInScope(int scope)</code></td><td>获取某范围的参数名称的集合。</td></tr><tr><td><code>getException()</code></td><td>获取<code>exception</code>对象。</td></tr><tr><td><code>getRequest()</code></td><td>获取<code>request</code>对象。</td></tr><tr><td><code>getResponse()</code></td><td>获取<code>response</code>对象。</td></tr><tr><td><code>getSession()</code></td><td>获取<code>session</code>对象。</td></tr><tr><td><code>getOut()</code></td><td>获取<code>out</code>对象。</td></tr><tr><td><code>setAttribute(String name,Object value)</code></td><td>为指定范围内的属性设置属性值。</td></tr><tr><td><code>removeAttribute(String name)</code></td><td>删除指定范围内的指定对象。</td></tr></tbody></table><p> <strong>说明：</strong><code>pageContext</code>对象在实际JSP开发过程中很少使用，因为<code>request</code>和<code>response</code>等对象均为内置对象，如果通过<code>pageContext</code>对象来调用这些对象比较麻烦。 </p><blockquote><p>感谢您的观看！</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JSP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JSP内置对象（一）</title>
      <link href="/2019/11/01/jsp-nei-zhi-dui-xiang-1/"/>
      <url>/2019/11/01/jsp-nei-zhi-dui-xiang-1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文章部分参考<a href="https://blog.csdn.net/pan_junbiao/article/details/87916435" target="_blank" rel="noopener">https://blog.csdn.net/pan_junbiao/article/details/87916435</a></p></blockquote><blockquote><p><a href="/2019/11/10/jsp-nei-zhi-dui-xiang-2">点击跳转JSP内置对象（二）</a></p><p><a href="/2019/11/10/jsp-nei-zhi-dui-xiang-3">点击跳转JSP内置对象（三）</a></p></blockquote><p>JSP提供了由容器实现和管理的内置对象，也可以称之为隐含对象，由于JSP使用Java作为脚本语言，所以JSP将具有强大的对象处理能力，并且可以动态创建Web页面内容。但Java语法在使用一个对象前，需要先实例化这个对象，这其实是一件比较烦琐的事情。JSP为了简化开发，提供了一些内置对象，用来实现很多JSP应用。在使用JSP内置对象时，不需要先定义这些对象，直接使用即可。</p><blockquote><p> 在JSP中一共预先定义了<strong>9</strong>个这样的对象，分别为<code>request</code>、<code>response</code>、<code>session</code>、<code>application</code>、<code>out</code>、<code>pageContext</code>、<code>config</code>、<code>pag</code>和<code>exception</code>。 </p></blockquote><table><thead><tr><th>内置对象</th><th>类型</th></tr></thead><tbody><tr><td><code>request</code></td><td>javax.servlet.http.HttpServletRequest</td></tr><tr><td><code>response</code></td><td>javax.servlet.http.HttpServletResponse</td></tr><tr><td><code>session</code></td><td>javax.servlet.http.HttpSession</td></tr><tr><td><code>application</code></td><td>javax.servlet.ServletContext</td></tr><tr><td><code>out</code></td><td>javax.servlet.jsp.JspWriter</td></tr><tr><td><code>pageContext</code></td><td>javax.servlet.jsp.PageContext</td></tr><tr><td><code>config</code></td><td>javax.servlet.ServletConfig</td></tr><tr><td><code>page</code></td><td>javax.servlet.jsp.JspPage</td></tr><tr><td><code>exception</code></td><td>javax.servlet.jsp.JspException</td></tr></tbody></table><h3 id="一、request对象"><a href="#一、request对象" class="headerlink" title="一、request对象"></a>一、request对象</h3><blockquote><p><code>request</code>对象封装了由客户端生成的<code>HTTP</code>请求的所有细节，主要包括<code>HTTP</code>头信息、系统信息、请求方式和请求参数等。通过<code>request</code>对象提供的相应方法可以处理客户端浏览器提交的<code>HTTP</code>请求中的各项参数。</p></blockquote><p><code>request</code>对象的常用方法：</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>String getParameter(String name)</code></td><td>根据页面表单组件名称获取页面提交数据。</td></tr><tr><td><code>String[] getParameterValues(String name)</code></td><td>获取一个页面表单组件对于多个值时的用户的请求数据。</td></tr><tr><td><code>void setCharacterEncoding(String env)</code></td><td>指定每个请求的编码，在调用<code>request.getParameter()</code> 方法之前进行设定，可以用于解决中文乱码问题。</td></tr><tr><td><code>request.getRequestDispatcher(String path)</code></td><td>返回一个 <code>javax.servlet.RequestDispatcher</code> 对象，该对象的<code>forward</code>方法用于转发请求。</td></tr><tr><td><code>void setAttribute(String name,Object object)</code></td><td>方法将数据保存到<code>request</code>范围内的变量中。</td></tr><tr><td><code>Object getAttribute(String name)</code></td><td>获取<code>request</code>范围内的变量中的数据。</td></tr><tr><td><code>void removeAttribute(String name)</code></td><td>删除<code>request</code>范围内的变量中的数据。</td></tr><tr><td><code>Cookie[] getCookies()</code></td><td>获取到所有<code>cookie</code>对象的集合。</td></tr></tbody></table><h4 id="1-1-访问请求参数"><a href="#1-1-访问请求参数" class="headerlink" title="1.1 访问请求参数"></a>1.1 访问请求参数</h4><p>我们知道<code>request</code>对象用于处理<code>HTTP</code>请求中的各项参数。在这些参数中，最常用的就是获取访问请求参数。当我们通过超链接的形式发送请求时，可以为该请求传递参数，这可以通过在超链接的后面加上问号“<code>?</code>”来实现。注意这个问号为<strong>英文半角</strong>的符号。</p><p>如果要同时指定多个参数，各参数间使用与符号“<code>&amp;</code>”分隔即可。</p><p><strong>示例：</strong>在页面中定义超链接。</p><pre class=" language-jsp"><code class="language-jsp"><script type="text/html" style='display:block'><a herf="delete.jsp?id=1&pwaaword=2">删除</a></script></code></pre><p> 在<code>delete.jsp</code>页面中，可以通过<code>request</code>对象的<code>getParameter()</code>方法获取传递的参数值。 </p><pre class=" language-jsp"><code class="language-jsp"><%    //获取id参数的值    String id = request.getParameter("id");  %></code></pre><p> <strong>示例：</strong>编程学员注册功能。要求提交注册信息后，显示学员输入的数据。 </p><p><strong>（1）</strong>注册页面 <code>reginput.jsp</code>。</p><pre class=" language-jsp"><code class="language-jsp"><script type="text/html" style='display:block'><%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%><!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"><html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>学员注册</title></head><body>    <div align="center">请输入注册信息        <form name="form1" method="post" action="reginfo.jsp">            <table border="0" align="center">                <tr>                    <td>用户姓名：</td>                    <td><input type="text" name="name" style="width:250px;" /></td>                </tr>                <tr>                    <td>博客地址：</td>                    <td><input type="text" name="blog" style="width:250px;"/></td>                </tr>                <tr>                    <td>兴趣爱好：</td>                    <td>                        <input type="checkbox" name="interests" value="足球" />足球                        <input type="checkbox" name="interests" value="篮球" />篮球                        <input type="checkbox" name="interests" value="羽毛球" />羽毛球                        <input type="checkbox" name="interests" value="乒乓球" />乒乓球                    </td>                </tr>                <!-- 以下是提交、取消按钮 -->                <tr>                    <td>                        <input type="submit" value="提交" />                    </td>                    <td>                        <input type="reset" value="取消" />                    </td>                </tr>            </table>        </form>    </div></body></html></script></code></pre><p><strong>（2）</strong>注册页面 <code>reginfo.jsp</code>。</p><pre class=" language-jsp"><code class="language-jsp"><script type="text/html" style='display:block'><%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%><!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"><html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>注册提交</title></head><body><%                //设置请求编码    request.setCharacterEncoding("UTF-8");                   //获取用户名    String name = request.getParameter("name");                  //获取博客地址    String blog = request.getParameter("blog");      //获取兴趣爱好    String[] interests = request.getParameterValues("interests");    String interStr = "";    if(interests != null)    {        for(String item : interests)        {            interStr += item + ";";        }    }%>    用户姓名：<%= name %><br/>    博客地址：<%= blog %><br/>    兴趣爱好：<%= interStr %></body></html></script></code></pre><p><strong>执行结果：</strong></p><p><strong>（1）</strong>注册页面 <code>reginput.jsp</code>：</p><img src="//czongz.github.io/2019/11/01/jsp-nei-zhi-dui-xiang-1/1.png"><p><strong>（2）</strong>注册提交页面 <code>reginfo.jsp</code>：</p><img src="//czongz.github.io/2019/11/01/jsp-nei-zhi-dui-xiang-1/2.png"><h4 id="1-2-在作用域中管理属性"><a href="#1-2-在作用域中管理属性" class="headerlink" title="1.2 在作用域中管理属性"></a>1.2 在作用域中管理属性</h4><p> 在进行请求转发时，需要把一些数据传递到转发后的页面进行处理。这时，就需要使用<code>request</code>对象的<code>setAttribute()</code>方法将数据保存到<code>request</code>范围内的变量中。<code>request</code>对象的<code>setAttribute()</code>方法的语法格式如下： </p><pre class=" language-jsp"><code class="language-jsp">request.setAttribute(String name,Object object);</code></pre><p> 在将数据保存到<code>request</code>范围内的变量中后，可以通过<code>request</code>对象的<code>getAttribute()</code>方法获取该变量的值，具体的语法格式如下： </p><pre class=" language-jsp"><code class="language-jsp">request.getAttribute(String name);</code></pre><h4 id="1-3-获取cookie"><a href="#1-3-获取cookie" class="headerlink" title="1.3 获取cookie"></a>1.3 获取cookie</h4><p><code>cookie</code>的中文意思是小甜饼，然而在互联网上的意思与这就完全不同了。它和食品完全没有关系。在互联网中，<code>cookie</code>是小段的文本信息，在网络服务器上生成，并发送给浏览器的。通过使用<code>cookie</code>可以标识<strong>用户身份</strong>，<strong>记录用户名和密码</strong>，<strong>跟踪重复用户</strong>等。浏览器将<code>cookie</code>以<code>key</code>/<code>value</code>的形式保存到客户机的某个指定目录中。</p><p>通过<code>cookie</code>的<code>getCookies()</code>方法即可获取到所有<code>cookie</code>对象的集合；通过<code>cookie</code>对象的<code>getName()</code>方法可以获取到指定名称的<code>cookie</code>；通过<code>getValue()</code>方法即可获取到<code>cookie</code>对象的值。另外将一个<code>cookie</code>对象发送到客户端使用了<code>response</code>对象的<code>addCookie()</code>方法。</p><p><strong>示例：</strong>通过<code>cookie</code>保存用户信息。</p><p><strong>（1）</strong>写入<code>cookie</code>对象页面 <code>index.jsp</code>。</p><pre class=" language-jsp"><code class="language-jsp"><script type="text/html" style='display:block'><%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%><!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"><html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>写入cookie对象</title></head><body><%    /**    *写入cookie的值    */             //设置请求的编码    request.setCharacterEncoding("UTF-8");                 //创建并实例化cookie对象    Cookie cookie = new Cookie("userCookie","指人猫的博客");          //设置cookie有效期为两周    cookie.setMaxAge(60*60*24*14);           //保存cookie对象    response.addCookie(cookie);         //创建一个cookie数组，并获取当前存入的值    Cookie [] cookies = request.getCookies();     if(cookies!=null){ //判断是否写入成功                //利用out对象输出信息        out.print("<h3>写入对象成功。</h3>");         }else{        out.print("<h3>写入对象失败。</h3>");     }%>   <a href="deal.jsp">查看cookie内容</a></body></html></script></code></pre><p><strong>（2）</strong>读取<code>cookie</code>值页面<code>deal.jsp</code>。</p><pre class=" language-jsp"><code class="language-jsp"><script type="text/html" style='display:block'><%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%><!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"><html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>读取cookie值</title></head><body><%    /**    *读取cookie的值    */        //从request中获取cookie对象的集合    Cookie[] cookies = request.getCookies();      String user = ""; //创建接收cookie值的容器    if(cookies != null) //如果cookie里面的值不为空则执行以下操作    {        //遍历cookie对象集合        for(Cookie cookieItem : cookies)        {            //获取cookie的name并判断是否为咱们设置的userCookie            if(cookieItem.getName().equals("userCookie"))             {                    //读取cookie对象的的值                user = cookieItem.getValue();                  //利用out对象把cookie的值输出出来                out.print("<h3>"+user+"</h3>");             }        }    }else{        out.print("cookie里值为空。");    }%></body></html></script></code></pre><p><strong>执行结果：</strong></p><p><strong>（1）</strong>写入<code>cookie</code>页面：</p><img src="//czongz.github.io/2019/11/01/jsp-nei-zhi-dui-xiang-1/3.png"><p><strong>（2）</strong>读取<code>cookie</code>页面：</p><img src="//czongz.github.io/2019/11/01/jsp-nei-zhi-dui-xiang-1/4.png"><h4 id="1-4-解决中文乱码"><a href="#1-4-解决中文乱码" class="headerlink" title="1.4 解决中文乱码"></a>1.4 解决中文乱码</h4><p>当请求参数的文字编码方式与页面中的不一致时，页面中的中文就会显示成乱码。所有的<code>request</code>请求都是<code>iso-8859-1</code>的，而在此页面采用的是<code>UTF-8</code>的编码方式。要解决此问题，只要将获取到的数据通过<code>String</code>的构造方法使用指定的编码类型重新构造一个<code>String</code>对象即可正确地显示出中文信息。 </p><pre class=" language-jsp"><code class="language-jsp"><script type="text/html" style='display:block'><body>    <a href="deal.jsp?name=张三&sex=男">解决中文乱码</a></body></script></code></pre><pre class=" language-jsp"><code class="language-jsp"><script type="text/html" style='display:block'><body>    name参数的值为：<%=new String(request.getParameter("name").getBytes("iso-8859-1"),"UTF-8") %><br>    sex参数的值为：<%=request.getParameter("sex") %></body></script></code></pre><h4 id="1-5-获取客户端信息"><a href="#1-5-获取客户端信息" class="headerlink" title="1.5 获取客户端信息"></a>1.5 获取客户端信息</h4><p>通过<code>request</code>对象可以获取客户端的相关信息，如<code>HTTP</code>报头信息，客户信息提交方式、客户端主机IP地址、端口号等。</p><p><code>request</code>获取客户端信息的常用方法：</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>getHeader(String name)</code></td><td>获取HTTP协议定义的文件头信息。</td></tr><tr><td><code>getHeaders(String name)</code></td><td>返回指定名字的<code>request Header</code>的所有值，其结果是一个枚举型的示例。</td></tr><tr><td><code>getHeaderNames()</code></td><td>返回所有<code>request Header</code>的名字，其结果是一个枚举型的实例。</td></tr><tr><td><code>getMethod()</code></td><td>获取客户端向服务器端传送数据的方法，如<code>get</code>、<code>post</code>、<code>header</code>、<code>trace</code>等。</td></tr><tr><td><code>getProtocol()</code></td><td>获取客户端向服务器端传送数据所依据的协议名称。</td></tr><tr><td><code>getRequestURI()</code></td><td>获取发出请求字符串的客户端地址，不包括请求参数。</td></tr><tr><td><code>getRequestURL()</code></td><td>获取发出请求字符串的客户端地址。</td></tr><tr><td><code>getRealPath(String path)</code></td><td>返回当前请求文件的绝对路径。</td></tr><tr><td><code>getRemoteAddr()</code></td><td>获取客户端的IP地址。</td></tr><tr><td><code>getRemoteHost()</code></td><td>获取客户端的主机名。</td></tr><tr><td><code>getServerName()</code></td><td>获取服务器的名字。</td></tr><tr><td><code>getServletPath()</code></td><td>获取客户端所请求的脚本文件的文件路径。</td></tr><tr><td><code>getServerPort()</code></td><td>获取服务器的端口号。</td></tr></tbody></table><p><strong>示例：</strong>用<code>request</code>对象的相关方法获取客户端信息。</p><pre class=" language-jsp"><code class="language-jsp"><script type="text/html" style='display:block'><%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%><!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"><html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>获取客户端信息</title></head><body>客户提交信息的方式：<%=request.getMethod()%><br>使用的协议：<%=request.getProtocol()%><br>获取发出请求字符串的客户端地址：<%=request.getRequestURI()%><br>获取发出请求字符串的客户端地址：<%=request.getRequestURL()%><br>获取提交数据的客户端IP地址：<%=request.getRemoteAddr()%><br>获取服务器端口号：<%=request.getServerPort()%><br>获取服务器的名称：<%=request.getServerName()%><br>获取客户端的主机名：<%=request.getRemoteHost()%><br>获取客户端所请求的脚本文件的文件路径:<%=request.getServletPath()%><br>获得Http协议定义的文件头信息Host的值:<%=request.getHeader("host")%><br>获得Http协议定义的文件头信息User-Agent的值:                        <%=request.getHeader("user-agent")%><br>获得Http协议定义的文件头信息accept-language的值:                        <%=request.getHeader("accept-language")%><br>获得请求文件的绝对路径:<%=request.getRealPath("show.jsp")%></body></html></script></code></pre><p><strong>执行结果：</strong></p><img src="//czongz.github.io/2019/11/01/jsp-nei-zhi-dui-xiang-1/5.png"><h4 id="1-6-显示国际化信息"><a href="#1-6-显示国际化信息" class="headerlink" title="1.6 显示国际化信息"></a>1.6 显示国际化信息</h4><p>浏览器可以通过<code>accept-language</code>的<code>HTTP</code>报头向<code>Web</code>服务器指明它所使用的本地语言。<code>request</code>对象中的<code>getLocale()</code>和<code>getLocales()</code>方法允许JSP开发人员获取这一信息，获取的信息属于<code>java.util.Local</code>类型。<code>java.util.Local</code>类型的对象封装了一个国家和一种国家所使用的语言。使用这一信息，JSP开发者就可以使用语言所特有的信息作出响应。</p><p><strong>示例：</strong>页面信息国际化。</p><pre class=" language-jsp"><code class="language-jsp"><script type="text/html" style='display:block'><%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%><!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"><html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>显示国际信息</title></head><body>    <%    java.util.Locale locale = request.getLocale(); //获取本地语言    String str = "";    if(locale.equals(java.util.Locale.US))  //判断本地语言    {        str = "Hello, Welcome to czongz's blog!";    }    else if(locale.equals(java.util.Locale.CHINA))    {        str = "您好，欢迎访问指人猫的博客！";    }%><%= str %></body></html></script></code></pre><p><strong>执行结果：</strong></p><img src="//czongz.github.io/2019/11/01/jsp-nei-zhi-dui-xiang-1/6.png"><h3 id="二、response对象"><a href="#二、response对象" class="headerlink" title="二、response对象"></a>二、response对象</h3><blockquote><p><code>response</code>对象用于响应客户请求，向客户端输出信息。它封装了JSP产生的响应，并发送到客户端以响应客户端的请求。请求的数据可以是各种数据类型，甚至是文件。<code>response</code>对象在JSP页面内有效。</p></blockquote><p><code>request</code>对象的常用方法：</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>sendRedirect(String path)</code></td><td>将网页重定向到另一个页面。</td></tr><tr><td><code>setHeader(String name, String value)</code></td><td>设置HTTP响应报头信息。</td></tr></tbody></table><h4 id="2-1-重定向网页"><a href="#2-1-重定向网页" class="headerlink" title="2.1 重定向网页"></a>2.1 重定向网页</h4><p>使用<code>response</code>对象提供的<code>sendRedirect()</code>方法可以将网页重定向到另一个页面。重定向操作支持将地址重定向到不同的主机上，这一点与转发不同。在客户端浏览器上将会得到跳转的地址，并重新发送请求链接。用户可以从浏览器的地址栏中看到跳转后的地址。进行重定向操作后，<code>request</code>中的属性<strong>全部失效</strong>，并且开始一个<strong>新</strong>的<code>request</code>对象。<code>sendRedirect()</code>方法的语法格式如下：</p><pre class=" language-jsp"><code class="language-jsp">response.sendRedirect(String path);</code></pre><p>参数说明：</p><p> <code>path</code>：用于指定目标路径，可以是相对路径，也可以是不同主机的其他URL地址。 </p><p> <strong>示例：</strong>使用<code>response</code>对象提供的<code>sendRedirect()</code>方法重定向到登录页面。 </p><pre class=" language-jsp"><code class="language-jsp"><script type="text/html" style='display:block'><%    response.sendRedirect("login.jsp");  //重定向到登录页面%></script></code></pre><h4 id="2-2-处理HTTP文件头"><a href="#2-2-处理HTTP文件头" class="headerlink" title="2.2 处理HTTP文件头"></a>2.2 处理HTTP文件头</h4><p>通过<code>response</code>对象可以设置<code>HTTP</code>响应报头，其中，最常用的是<strong>禁用缓存</strong>、<strong>设置页面自动刷新</strong>和<strong>定时跳转网页</strong>。下面分别进行介绍。</p><p>设置<code>HTTP</code>响应报头方法的语法格式如下：</p><pre class=" language-jsp"><code class="language-jsp">response.setHeader(String name, String value);</code></pre><h5 id="2-2-1-禁用缓存"><a href="#2-2-1-禁用缓存" class="headerlink" title="2.2.1 禁用缓存"></a>2.2.1 禁用缓存</h5><p>在默认情况下，浏览器将会对显示的网页内容进行缓存，这样可以提高网页的显示速度。对于一些安全性要求比较高的网站，通常需要禁用缓存。</p><p><strong>示例：</strong>通过设置<code>HTTP</code>头的方式实现禁用缓存。</p><pre class=" language-jsp"><code class="language-jsp"><script type="text/html" style='display:block'><%    response.setHeader("Cache-Control", "no-store");    response.setDateHeader("Expires", 0);%></script></code></pre><h5 id="2-2-2-设置页面自动刷新"><a href="#2-2-2-设置页面自动刷新" class="headerlink" title="2.2.2 设置页面自动刷新"></a>2.2.2 设置页面自动刷新</h5><p>通过设置<code>HTTP</code>头还可以实现页面的自动刷新。</p><p><strong>示例：</strong>使页面每隔10秒自动刷新一次。</p><pre class=" language-jsp"><code class="language-jsp"><script type="text/html" style='display:block'><%    response.setHeader("refresh", "10");  //后面参数是10s%></script></code></pre><h5 id="2-2-3-定时跳转页面"><a href="#2-2-3-定时跳转页面" class="headerlink" title="2.2.3 定时跳转页面"></a>2.2.3 定时跳转页面</h5><p>通过设置<code>HTTP</code>头还可以实现定时跳转页面功能。</p><p><strong>示例：</strong>使页面5秒后自动跳转到指定的网页。</p><pre class=" language-jsp"><code class="language-jsp"><script type="text/html" style='display:block'><%    //后面参数要写上秒数和url中间分号分割    response.setHeader("refresh", "5;URL=login.jsp"); %></script></code></pre><h4 id="2-3-设置输出缓冲"><a href="#2-3-设置输出缓冲" class="headerlink" title="2.3 设置输出缓冲"></a>2.3 设置输出缓冲</h4><p>通常情况下，服务器要输出到客户端的内容不会直接写到客户端，而是先写到一个输出缓冲区，在计算机术语中，缓冲区被定义为暂时放置输入或输出资料的内存。实际上，缓冲区也可以这样理解：在一个粮库中，由于装缷车队的速度要快于传送带的传输速度，为了不造成装缷车队的浪费，粮库设计了一个站台，装缷车队可以先将运送的粮食缷到这个平台上，然后让传送机慢慢传送。粮库的这个站台就起到了缓冲的作用。</p><p><code>response</code>对象提供的对缓冲区进行配置的方法：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td><code>flushBuffer()</code></td><td>强制将缓冲区的内容输出到客户端。</td></tr><tr><td><code>getBufferSize()</code></td><td>获取响应所使用的缓冲区的实际大小，如果没有使用缓冲区，则返回0。</td></tr><tr><td><code>setBufferSize(int size)</code></td><td>设置缓冲区大小。</td></tr><tr><td><code>reset()</code></td><td>清除缓冲区的内容，同时清除状态码和报头。</td></tr><tr><td><code>isCommitted()</code></td><td>检查服务器端是否已经把数据写入到客户端。</td></tr></tbody></table><p> <strong>示例：</strong>设置缓冲区的大小为32KB。 </p><pre class=" language-jsp"><code class="language-jsp"><script type="text/html" style='display:block'><%    response.setBufferSize(32);%></script></code></pre><p> <strong>说明：</strong>如果将缓冲区的大小设置为0KB，则表示不缓冲。 </p><h3 id="三、session对象"><a href="#三、session对象" class="headerlink" title="三、session对象"></a>三、session对象</h3><blockquote><p><code>session</code>在网络中被称为会话。由于<code>HTTP</code>协议是一种无状态协议，也就是当一个客户向服务器发出请求，服务器接收请求，并返回响应后，该连接就结束了，而服务器并不保存相关的信息。为了弥补这一缺点，<code>HTTP</code>协议提供了<code>session</code>。通过<code>session</code>可以在应用程序的Web页面间进行跳转时，保存用户的状态，使整个用户会话一直存在下去，直到关闭浏览器。但是，如果在一个会话中，客户端长时间不向服务器发出请求，<code>session</code>对象就会自动消失。这个时间取决于服务器，例如，Tomcat服务器默认为30分钟。不过这个时间可以通过编写程序进行修改。</p></blockquote><p> <code>session</code>对象的常用方法：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td><code>setAttribute(String name,Object value)</code></td><td>该方法用于将信息保存到<code>session</code>范围内。</td></tr><tr><td><code>Object getAttribute(String name)</code></td><td>该方法用于获取<code>session</code>信息，返回值为<code>Object</code>类型。</td></tr><tr><td><code>removeAttribute(String name)</code></td><td>移除<code>session</code>对象。</td></tr><tr><td><code>invalidate()</code></td><td>销毁<code>session</code>对象。</td></tr><tr><td><code>long getLastAccessedTime()</code></td><td>返回客户端最后一次与会话相关联的请求时间。</td></tr><tr><td><code>int getMaxInactiveInterval()</code></td><td>以秒为单位返回一个会话内两次请求最大时间间隔。</td></tr><tr><td><code>setMaxInactiveInterval(int interval)</code></td><td>以秒为单位设置<code>session</code>的有效时间。</td></tr><tr><td><code>long getCreationTime()</code></td><td>返回<code>session</code>对象被创建的时间， 以毫秒为单位，从1970年1月1号凌晨开始算起。</td></tr><tr><td><code>String getId()</code></td><td>返回<code>session</code>对象的ID。</td></tr><tr><td><code>boolean isNew()</code></td><td>返回是否为一个新的客户端，或者客户端是否拒绝加入<code>session</code>。</td></tr></tbody></table><p> <strong>示例：</strong>保存与获取session对象信息。 </p><pre class=" language-jsp"><code class="language-jsp"><script type="text/html" style='display:block'><%              //保存session对象    session.setAttribute("UserName", "指人猫的博客");             //获取session对象    String userName = session.getAttribute("UserName").toString();  %></script></code></pre><p><strong>配置web.xml文件：</strong></p><p>如果使用的是Tomcat，可以向下面这样配置web.xml文件：</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>session-config</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>session-timeout</span><span class="token punctuation">></span></span>15<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>session-timeout</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>session-config</span><span class="token punctuation">></span></span></code></pre><p>超时以分钟为单位，Tomcat中的默认的超时时间是<strong>30</strong>分钟。</p><p>Servlet中的<code>getMaxInactiveInterval( )</code>方法以秒为单位返回超时时间。如果在web.xml中配置的是15分钟，则<code>getMaxInactiveInterval( )</code>方法将会返回<strong>900</strong>。</p><blockquote><p>感谢您的观看！</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JSP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue风格的Typora主题</title>
      <link href="/2019/10/30/vue-feng-ge-de-typora-zhu-ti/"/>
      <url>/2019/10/30/vue-feng-ge-de-typora-zhu-ti/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文章部分参考于<a href="https://blinkfox.github.io" target="_blank" rel="noopener">https://blinkfox.github.io</a>。</p></blockquote><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><a href="https://www.typora.io/" target="_blank" rel="noopener">Typora</a> 是一款支持实时预览的 Markdown 编辑器和阅读器，支持<code>Windows</code>、<code>macOS</code>、<code>Linux</code>三大平台。Typora 作为一款合格的 Markdown 编辑器，支持图片、列表、表格、代码、公式、目录等功能，同时这款软件还支持（一键）动态预览功能，让一切都变得如此干净、纯粹。并且有多种主题模板。<strong>该文章就是参考了<a href="https://vuejs.org/" target="_blank" rel="noopener">Vue</a>文档风格而开发的一个 Typora 自定义主题。</strong></p><h3 id="安装主题"><a href="#安装主题" class="headerlink" title="安装主题"></a>安装主题</h3><p><strong>1.</strong>下载<strong><a href="https://github.com/blinkfox/typora-vue-theme" target="_blank" rel="noopener">该链接</a></strong>的ZIP压缩包。</p><img src="/blog//czongz.gitee.io/blog/2019/10/30/vue-feng-ge-de-typora-zhu-ti/1.png" style="zoom:50%;"><p><strong>2.</strong>打开Typora，点击“<strong>文件</strong>”=&gt;“<strong>偏好设置</strong>”=&gt;“<strong>外观</strong>“=&gt;“<strong>打开主题文件夹</strong>”按钮，将弹出Typora的主题文件夹。</p><p><img src="/blog//czongz.gitee.io/blog/2019/10/30/vue-feng-ge-de-typora-zhu-ti/2.png" style="zoom:50%;"><img src="/blog//czongz.gitee.io/blog/2019/10/30/vue-feng-ge-de-typora-zhu-ti/3.png" style="zoom:50%;"></p><p><strong>3.</strong>将下载好的压缩包进行解压，只解压<code>vue.css</code>和<code>vue-dark.css</code>文件和包含字体的<code>vue</code>文件夹放到<code>Typora</code>的主题文件夹中。</p><p><img src="/blog//czongz.gitee.io/blog/2019/10/30/vue-feng-ge-de-typora-zhu-ti/4.png" style="zoom:50%;"> <img src="/blog//czongz.gitee.io/blog/2019/10/30/vue-feng-ge-de-typora-zhu-ti/5.png" style="zoom:50%;"></p><p><strong>4.</strong> 关闭并重新打开 <code>Typora</code>，从菜单栏中选择 “<strong>主题</strong>” =&gt; “<strong><code>Vue</code></strong>” 或者 “<strong><code>Vue Dark</code></strong>” 即可。 </p><img src="/blog//czongz.gitee.io/blog/2019/10/30/vue-feng-ge-de-typora-zhu-ti/6.png" style="zoom:50%;"><h3 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h3><p><img src="/blog//czongz.gitee.io/blog/2019/10/30/vue-feng-ge-de-typora-zhu-ti/7.png" alt></p><p><img src="/blog//czongz.gitee.io/blog/2019/10/30/vue-feng-ge-de-typora-zhu-ti/8.png" alt></p><p><img src="/blog//czongz.gitee.io/blog/2019/10/30/vue-feng-ge-de-typora-zhu-ti/9.png" alt></p><p><img src="/blog//czongz.gitee.io/blog/2019/10/30/vue-feng-ge-de-typora-zhu-ti/10.png" alt></p><blockquote><p>感谢您的观看！</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> Typora </tag>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java知识点总结</title>
      <link href="/2019/10/13/java-zhi-shi-dian-zong-jie/"/>
      <url>/2019/10/13/java-zhi-shi-dian-zong-jie/</url>
      
        <content type="html"><![CDATA[<h3 id="第一章：什么是面向对象"><a href="#第一章：什么是面向对象" class="headerlink" title="第一章：什么是面向对象"></a>第一章：什么是面向对象</h3><ul><li><strong>概念：</strong>面向对象就是把一个项目，一个事情分成更小的项目，或者说分成一个个更小的部分，每一部分负责什么方面的功能，最后再由这些部分组合而成为一个整体。</li><li><strong>好处：</strong>面向对象更接近实物的本质，提高代码的复用更具有扩展性。</li><li><strong>如何使用：</strong>通常是创建类的对象再给属性赋值。</li></ul><h3 id="第二章：类和对象的创建"><a href="#第二章：类和对象的创建" class="headerlink" title="第二章：类和对象的创建"></a>第二章：类和对象的创建</h3><ul><li><p><strong>类的创建：</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> 类名<span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre></li></ul><ul><li><p><strong>对象的创建：</strong></p><pre class=" language-java"><code class="language-java">类名 变量名 <span class="token operator">=</span> <span class="token keyword">new</span> 类名<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li></ul><ul><li><p><strong>构造方法：</strong>构造方法的名称和类名相同，没有返回值类型。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> 类名<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre></li></ul><ul><li><p><strong>构造方法的重载：</strong>方法名相同，参数列表不同，这是构造方法的重载。<br>如果一个类中包含了两个或两个以上的方法，他们方法名相同，方法参数个数或者参数类型不同，则称该方法被重载了，这个过程是方法重载。</p></li><li><p><strong><code>Static</code>：</strong>可以用来修饰属性，方法和代码块，静态方法中不能使用<code>this</code>和<code>super</code>关键字。</p></li></ul><h3 id="第三章：封装"><a href="#第三章：封装" class="headerlink" title="第三章：封装"></a>第三章：封装</h3><ul><li><p><strong>概念：</strong>封装指的是将对象的状态信息隐藏在对象内部，不允许外部程序直接访问对象内部信息，而是通过该类所提供的方法来实现对内部信息的操作访问。</p></li><li><p><strong>好处：</strong>提高了安全性、提高了复用性、提高了实现细节。</p></li><li><p><strong>注意事项：</strong>类的属性中均用<code>private</code>来修饰，定义<code>get</code>和<code>set</code>方法。</p></li></ul><h3 id="第四章：继承"><a href="#第四章：继承" class="headerlink" title="第四章：继承"></a>第四章：继承</h3><ul><li><p><strong>概念：</strong>比如FeiGe快递系统中有三个实体类<code>Person</code>，<code>Courier</code>, <code>Customer</code>类，<code>Courier</code>, <code>Customer</code>都属于<code>Person</code>，所以都继承自<code>Person</code>类。</p></li><li><p><strong>好处：</strong>提高了代码的重用性，提高了代码的扩展性。</p></li><li><p><strong>语法：</strong></p></li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> 类名 <span class="token keyword">extends</span> 父类<span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//属性定义</span>    <span class="token comment" spellcheck="true">//方法定义</span><span class="token punctuation">}</span></code></pre><ul><li><p><strong>注意事项：</strong></p><p><strong>1.</strong>子类继承父类所有的属性和方法，但是不能调用<code>Private</code>修饰的属性和方法。</p><p><strong>2.</strong>.java中的继承只支持单继承，意思是一个子类只能继承一个父类，但是允许多层继承。</p></li><li><p><strong>继承中的构造方法：</strong>调用父类中的构造方法，需用到关键字<code>super</code>, <code>super</code>指代父类。</p></li><li><p><strong>重写的概念：</strong>在继承的关系中，子类会自动继承父类中定义的方法，但有时子类中需要对继承的方法进行一些内容上的修改，即对父类的方法进行重写。</p></li><li><p><strong>重写注意事项：</strong>子类重写父类的方法时，不能使用比父类中被重写的方法更严格的访问权限，重写方法和被重写方法必须具有相同的方法名，相同的参数列表和相同的返回值类型，重写方法的访问修饰符必须大于被重写方法的访问修饰符，否则就不能被称为方法的重写。</p></li><li><p><strong>异常处理：</strong>在程序执行代码的时候万一发生了异常，程序会按照预定的处理方法对异常进行处理，异常处理完毕之后，程序继续运行。<br><strong>语法：</strong>  <strong><em>5</em></strong>个关键字 <code>try</code> , <code>catch</code>, <code>finally</code>, <code>throw</code>, <code>throws</code>.</p></li><li><p><strong>常见的异常类型：</strong></p><ul><li><code>Exception</code>  异常层次的根类 </li><li><code>ArithmeticException</code>  算术错误情形，如以零作除数</li><li><code>ArrayIndexOutOfBoundsException</code>  数组下标越界</li><li><code>NullPointerException</code>  空指针异常</li><li><code>ClassNotFoundException</code>  不能加载所需的类</li><li><code>InputMismatchException</code>  得到的数据类型与实际输入的类型不匹配</li><li><code>llegalArgumentException</code>  方法接收到非法参数</li><li><code>ClassCastException</code>  对象强制类型转换出错</li><li><code>NumberFormatException</code>  数字格式转换异常，如把“abc”转换成数字</li></ul></li></ul><h3 id="第五章：多态"><a href="#第五章：多态" class="headerlink" title="第五章：多态"></a>第五章：多态</h3><ul><li><p><strong>概念：</strong>指允许不同类的对象对同一消息做出响应即同同一消息可以根据发送对象的不同而采用多种不同的行为方式。</p></li><li><p><strong>好处：</strong>可替换性、可扩充性、接口性、灵活性、简化性。</p></li><li><p><strong>多态的使用：</strong></p><ul><li><p>子类向父类转换称为向上转型</p><p><em>向上转型：</em><code>父类 变量名 = new 子类();</code></p></li><li><p>将一个指向子类对象的父类引用赋给一个子类的引用，即将父类类型转换子类类型，称为向下转型，此时必须进行强制类型转换。</p><p><em>向下转型：</em><code>子类 变量名 = (子类) 父类的变量名;</code></p></li></ul></li><li><p><strong>运算符：</strong><code>instance of</code>进行类型的判断。</p></li><li><p>*<em><code>try-catch-finally</code>:  *</em> <code>try</code>中的语句无论有没有异常<code>finally</code>块都将被执行。</p></li><li><p><strong>多重<code>catch</code> ：</strong>一段代码会出现多种异常这时可以在<code>try</code>语句后写多个<code>catch</code>语句块。</p></li></ul><h3 id="第六章：抽象"><a href="#第六章：抽象" class="headerlink" title="第六章：抽象"></a>第六章：抽象</h3><ul><li><p><strong>概念：</strong>如果一个类没有足够的信息去描述一个具体的对象那我们就称之为抽象类</p></li><li><p><strong>语法：</strong></p></li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> 类名<span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><ul><li><p><strong>作用：</strong>抽象类是用来继承的，比普通类更通用。</p></li><li><p><strong>抽象方法：</strong><code>abstract</code>修饰，没有方法体，声明返回的数据类型、方法名称和所需要的参数。</p><ul><li><p><strong><em>语法：</em></strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">abstract</span> 返回值类型 方法名 <span class="token punctuation">(</span>参数列表<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li></ul></li><li><p><strong>注意事项：</strong>包含抽象方法的类一定是抽象类，抽象类中不一定都是抽象方法，构造方法不能声明为抽象方法  <code>abstract</code>不能与<code>private</code>, <code>static</code>, <code>final</code>, <code>native</code> 并列修饰同一个方法。</p></li><li><p><strong><code>final</code>修饰类：</strong>被<code>final</code>修饰过的类不能被继承，因为不能被继承所以此类中所有方法都是<code>final</code>修饰，该类如果不需要有子类，不需要被扩展，类的方法不允许被重写就用<code>final</code>修饰该类。</p></li></ul><h3 id="第七章：接口"><a href="#第七章：接口" class="headerlink" title="第七章：接口"></a>第七章：接口</h3><ul><li><p><strong>概念：</strong>在软件中接口是一种规范和标准，他们可以约束类的行为，是一些方法特征的集合，但是没有方法的实现。</p></li><li><p><strong>语法：</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> 接口名<span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//常量定义</span>    <span class="token comment" spellcheck="true">//方法定义</span><span class="token punctuation">}</span></code></pre><p><strong>或者</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> 接口名 <span class="token keyword">extends</span> 父接口<span class="token number">1</span><span class="token punctuation">,</span> 父接口<span class="token number">2</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//常量定义</span>    <span class="token comment" spellcheck="true">//方法定义</span><span class="token punctuation">}</span></code></pre></li><li><p><strong>注意事项：</strong>接口可以多继承，类也可以实现多个接口，如果该类已经继承了父类那么<code>implements</code>要写在后面，类实现接口后，必须要重写接口中的方法。</p></li><li><p><strong>接口的实现：</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">extends</span> 父类 <span class="token keyword">implements</span> 接口<span class="token number">1</span><span class="token punctuation">,</span> 接口<span class="token number">2</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//重写接口方法</span><span class="token punctuation">}</span></code></pre></li><li><p><strong>抛出异常：</strong><code>throw</code> 除系统自动抛出异常可以用<code>throw</code>自动抛出异常，<code>throw</code>在程序中抛出异常，<code>throws</code>在方法内抛出异常。</p></li></ul><h3 id="第八章：集合框架"><a href="#第八章：集合框架" class="headerlink" title="第八章：集合框架"></a>第八章：集合框架</h3><ul><li><p><strong>集合框架的特点：</strong></p><ul><li><strong>长度：</strong>数组长度是固定的，集合长度是可变的。</li><li><strong>储存对象：</strong> 数组可以存储基本的数据类型，也可以存储对象的引用，集合只能用于存储对象的引用。</li><li><strong>对象类型：</strong> 数组必须是相同类型的数据 ，集合对象可以是不同类型。</li></ul></li><li><p><strong>接口的区别：</strong></p><ul><li><code>Collection</code>接口存储组，不唯一(允许重复)、 无序的对象。</li><li><code>Set</code>接口继承<code>Collection</code>接口，存储-组唯一(不允许重复)、 无序的对象。</li><li><code>List</code>接口继承<code>Collection</code>接口，存储组不唯-(允许重复)、 有序(以元素插入的次序来放置无素，不会重新排列)的对象。</li><li><code>Map</code>接口存储组成对的键 值对象，提供<code>key</code>(键)到<code>value</code>(值)的映射。<code>Map</code>中的<code>key</code>不要求有序，不允许重复。<code>value</code> 同样不要求有序，但允许重复。</li></ul></li><li><p><strong><code>List</code>接口：</strong>实现<code>List</code>接口的常用类有<code>ArrayList</code>和<code>Linkedist</code>.它们都可以容纳所有类型的对象，包括<code>null</code>允许重复，并且都保证元素的存储顺序。</p></li><li><p><strong><code>ArrayList</code>和<code>LinkedList</code>的大致区别：</strong><br><code>Arraylist</code>是实现了基于动态数组的数据结构，<code>LinkedList</code>基于链表的数据结构对于随机访问<code>get</code>和<code>set</code>, <code>ArrayList</code> 优于<code>LinkedList</code>, 因为<code>LinkedList</code>要移动指针。对于新增和删除操作<code>add</code>和<code>remove</code>, <code>LinkedList</code> 比较占优势，因为<code>ArrayList</code>要移动数据。</p></li><li><p><strong><code>list</code>接口定义中的各种常用方法：</strong></p><ul><li><p><code>boolean add(Object o)</code>在列表末尾顺序添加元素，起始索引位置从<strong>0</strong>开始。</p></li><li><p><code>int size()</code>返回列表中的元素个数。</p></li><li><p><code>void add(int index,Object o)</code>在指定的索引位置添加元素，原索引位置及其后面的元素依次后移。</p><blockquote><p><strong>注意：</strong>新添加元素的索引位置必须介于<strong>0</strong>和列表中<strong>元素个数</strong>之间。</p></blockquote></li><li><p><code>object get(int index)</code>返回指定索引位置处的元素。</p><blockquote><p><strong>注意：</strong>取出的元素是<code>object</code>类型，使用前需要进行强制类型转换。</p></blockquote></li><li><p><code>boolean contains(Object o)</code>判断列表中是否存在指定元素。</p></li><li><p><code>boolean remove(Object o)</code>从列表中删除元素。</p></li><li><p><code>object remove(int index)</code>从列表中删除指定位置元素，起始索引位置从0开始。</p></li></ul></li><li><p><strong><code>Linkedlist</code>的一些特殊用法：</strong></p><ul><li><code>void addFirst(Object o)</code>在列表的首部添加元素。</li><li><code>void addLast(Object o)</code>在列表的末尾添加元素。</li><li><code>object getFirst()</code>返回列表中的第一个元素。</li><li><code>object getLast()</code>返回列表中的最后一个元素。</li><li><code>object removeFirst()</code>删除并返回列表中的第一个元素。</li></ul></li><li><p><strong><code>Set</code>接口：</strong><br><code>Hashset</code>的优点就是各方面都很快但数据是无序的。<br><code>Threeset</code>优点是有序而且可以按照升序方式进行排序，但是其他各方面不突出。</p></li><li><p><strong><code>Map</code></strong>接口的一些常用方法：</p><ul><li><code>object put (object key，object value)</code>以“键一值对”的方式进行存储如果试图添加重复的键，那么最后加入的“键-值对”将替换掉原先的“键-值对”。</li><li><code>object get (Object key)</code>根据键返回相关联的值，若不存在指定的键，则返回<code>null</code>。</li><li><code>object remove (Object key)</code>删除指定的键映射的“键一值对”。</li><li><code>int size()</code>返回元素个数。</li><li><code>set keySet()</code>返回键的集合。</li><li><code>collection values()</code>返回值的集合。</li><li><code>boolean containsKey (Object key)</code>若存在指定的键映射的“键值对”，则返回<code>true。</code></li><li><code>boolean isEmpty()</code>若不存在键一值映射关系，则返回<code>true。</code></li><li><code>void clear()</code>从此映射中移除所有映射关系。</li></ul></li><li><p><strong>泛型：</strong></p><ul><li><code>ArrayList&lt;0bject&gt; list = new ArrayList&lt;0bject&gt;();</code></li><li><code>Map map&lt;Object,Object&gt; = new HashMap&lt;Object,Object&gt;();</code></li><li><code>ArrayList&lt;Map&lt;Object,Object&gt;&gt; list = new ArrayList&lt;Map&lt;Object,Object&gt;&gt;();</code></li></ul></li></ul><blockquote><p>感谢您的观看！</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo搭建个人博客</title>
      <link href="/2019/10/10/hexo-da-jian-ge-ren-bo-ke/"/>
      <url>/2019/10/10/hexo-da-jian-ge-ren-bo-ke/</url>
      
        <content type="html"><![CDATA[<blockquote><p>这个是我反复尝试、查阅资料后总结出的，为了能让你们更加快速的看到，我放弃了中午的午休给你们写了这篇博客，并且在室友电脑上也成功配置。想想都欠我些什么哈哈！</p></blockquote><p><em>首先此教程基本抛弃了老师发给的教程步骤，但是Git和Node.js还是要安装的。</em></p><h4 id="第一步：删除"><a href="#第一步：删除" class="headerlink" title="第一步：删除"></a>第一步：删除</h4><blockquote><p>因为是重新创建，所以要把之前的blog目录删掉。</p></blockquote><img src="//czongz.github.io/2019/10/10/hexo-da-jian-ge-ren-bo-ke/1.png" style="zoom:50%;"><h4 id="第二步：安装框架"><a href="#第二步：安装框架" class="headerlink" title="第二步：安装框架"></a>第二步：安装框架</h4><p>在<code>hexo</code>目录中打开<code>Git Bash</code></p><p>输入代码：<code>npm install hexo-cli -g</code></p><img src="//czongz.github.io/2019/10/10/hexo-da-jian-ge-ren-bo-ke/2.png"><blockquote><p>该过程根据电脑内存的不同可能会持续30s-60s，耐心等待</p></blockquote><h4 id="第三步：创建blog"><a href="#第三步：创建blog" class="headerlink" title="第三步：创建blog"></a>第三步：创建blog</h4><p>输入代码：<code>hexo init blog</code></p><img src="//czongz.github.io/2019/10/10/hexo-da-jian-ge-ren-bo-ke/3.png"><blockquote><p>该过程也是会持续一段时间</p></blockquote><h4 id="第四步：切换目录"><a href="#第四步：切换目录" class="headerlink" title="第四步：切换目录"></a>第四步：切换目录</h4><p>输入代码：<code>cd blog</code></p><img src="//czongz.github.io/2019/10/10/hexo-da-jian-ge-ren-bo-ke/4.png"><p><em>查看是否切换</em></p><img src="//czongz.github.io/2019/10/10/hexo-da-jian-ge-ren-bo-ke/5.png"><h4 id="第五步：安装组件"><a href="#第五步：安装组件" class="headerlink" title="第五步：安装组件"></a>第五步：安装组件</h4><p>输入代码：<code>npm install</code></p><img src="//czongz.github.io/2019/10/10/hexo-da-jian-ge-ren-bo-ke/6.png"><h4 id="第六步：生成静态页面"><a href="#第六步：生成静态页面" class="headerlink" title="第六步：生成静态页面"></a>第六步：生成静态页面</h4><p>输入代码：<code>hexo g</code></p><img src="//czongz.github.io/2019/10/10/hexo-da-jian-ge-ren-bo-ke/7.png"><h4 id="第七步：启动本地服务器"><a href="#第七步：启动本地服务器" class="headerlink" title="第七步：启动本地服务器"></a>第七步：启动本地服务器</h4><p>输入代码：<code>hexo s</code></p><img src="//czongz.github.io/2019/10/10/hexo-da-jian-ge-ren-bo-ke/8.png"><p>然后在浏览器输入网址：<code>localhost:4000</code></p><img src="//czongz.github.io/2019/10/10/hexo-da-jian-ge-ren-bo-ke/9.png" style="zoom:50%"><p>这只是本地博客，下面配置远端博客</p><p>在命令界面按<code>Ctrl</code>+<code>C</code>结束本地服务器</p><h4 id="第八步：布置deployer目录"><a href="#第八步：布置deployer目录" class="headerlink" title="第八步：布置deployer目录"></a>第八步：布置deployer目录</h4><p>输入代码：<code>npm install --save hexo-deployer-git</code></p><img src="//czongz.github.io/2019/10/10/hexo-da-jian-ge-ren-bo-ke/10.png"><blockquote><p>该过程需要一段时间的加载，耐心等待！</p></blockquote><h4 id="第九步：修改-config-yml文件"><a href="#第九步：修改-config-yml文件" class="headerlink" title="第九步：修改_config.yml文件"></a>第九步：修改_config.yml文件</h4><p>打开<code>hexo</code>根目录下的<code>_config.yml</code>文件，修改其<code>deploy</code>标签的内容(应该在最下面)</p><img src="//czongz.github.io/2019/10/10/hexo-da-jian-ge-ren-bo-ke/11.png"><p><strong><code>repo</code>后面的<code>Frightings</code>修改成你们自己的名字！冒号后面跟个空格！</strong></p><p>修改后输入代码：<code>hexo clean</code>清理缓存，</p><img src="//czongz.github.io/2019/10/10/hexo-da-jian-ge-ren-bo-ke/12.png"><p>然后输入代码：<code>hexo g</code>重新布置静态页面。</p><h4 id="第十步：布置远端博客"><a href="#第十步：布置远端博客" class="headerlink" title="第十步：布置远端博客"></a>第十步：布置远端博客</h4><p>输入代码：<code>hexo d</code></p><img src="//czongz.github.io/2019/10/10/hexo-da-jian-ge-ren-bo-ke/13.png"><p>然后他会让你告诉他，你是谁~（Please tell me who you are）</p><img src="//czongz.github.io/2019/10/10/hexo-da-jian-ge-ren-bo-ke/14.png"><p>接着咱们就告诉他，咱是谁~</p><p>输入代码：<code>git config --global user.email  &quot;youremail@qq.com&quot;</code></p><img src="//czongz.github.io/2019/10/10/hexo-da-jian-ge-ren-bo-ke/15.png"><p><strong>注意！ 这边<code>youremail@qq.com</code>不是让你照搬抄上！是让你写上你自己的邮箱！</strong></p><p>接着输入代码：<code>git config --global user.name  &quot;yourname&quot;</code></p><img src="//czongz.github.io/2019/10/10/hexo-da-jian-ge-ren-bo-ke/16.png"><p><strong>同样，这边<code>yourname</code>不是让你照搬抄上！是让你写上你自己的用户名。</strong></p><p>然后依次输入代码:<code>hexo clean</code>清理下缓存，</p><p><code>hexo g</code>生成静态页面，<code>hexo d</code>布置远端。</p><h4 id="第十一步：查看效果"><a href="#第十一步：查看效果" class="headerlink" title="第十一步：查看效果"></a>第十一步：查看效果</h4><p>然后在网站中输入你的博客地址<code>yourname.github.io</code>就会出现你的博客。</p><img src="//czongz.github.io/2019/10/10/hexo-da-jian-ge-ren-bo-ke/17.png" style="zoom:50%;"><h4 id="第十二步：写博客"><a href="#第十二步：写博客" class="headerlink" title="第十二步：写博客"></a>第十二步：写博客</h4><p>输入代码：<code>hexo new &quot;我的第一篇博客&quot;</code></p><img src="//czongz.github.io/2019/10/10/hexo-da-jian-ge-ren-bo-ke/18.png"><p>这上面写出了你的博客路径，找到他进行编辑。</p><img src="//czongz.github.io/2019/10/10/hexo-da-jian-ge-ren-bo-ke/19.png"><p>打开后：</p><img src="//czongz.github.io/2019/10/10/hexo-da-jian-ge-ren-bo-ke/20.png"><p>上面有个<code>tags</code>标签,目前没什么用，先<strong>删除</strong>，要不然可能会编译错误。</p><img src="//czongz.github.io/2019/10/10/hexo-da-jian-ge-ren-bo-ke/21.png"><p>编辑完之后：</p><img src="//czongz.github.io/2019/10/10/hexo-da-jian-ge-ren-bo-ke/22.png" style="zoom:50%;"><h4 id="第十三步：查看效果"><a href="#第十三步：查看效果" class="headerlink" title="第十三步：查看效果"></a>第十三步：查看效果</h4><p>十二步完成后，依次输入代码：<code>hexo clean</code>清理缓存，</p><p>输入代码：<code>hexo g</code>生成静态页面，</p><p>可以发现里面的<code>INFO</code>项中加载了自己写的博客。</p><img src="//czongz.github.io/2019/10/10/hexo-da-jian-ge-ren-bo-ke/23.png"><p>输入代码：<code>hexo d</code> 缓存到GitHub。</p><p>然后再刷新一下自己的博客地址，可以发现自己写的博客已经显示了。</p><img src="//czongz.github.io/2019/10/10/hexo-da-jian-ge-ren-bo-ke/24.png" style="zoom:50%;"><p><strong>如果需要继续添加文章，也是相同的步骤和代码。</strong></p><blockquote><p>感谢您的观看！</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
